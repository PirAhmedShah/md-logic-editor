import { suggestions, parameters } from "../Objects/main.js";
import { getParameterArray, isAutoGenerated } from "./utility.js";

export class Input {
  constructor(editor, keys) {
    //console.log("____CON INPUT____");
    this.editor = editor;
    this.previousKeyLog = "";
    this.keys = keys;
    this.logic = this.editor.logic

    editor.canvas.onkeydown = (e) => {
      this.onInput(e);
    };
  }
  onCharacterInput(word, line, key) {
    //console.log("____FUNC IN CHAR INPUT____");
    if (isAutoGenerated(word)) {
      line[this.active.word] = "";
      word = "";
    }

    if (getParameterArray(line, this.active.word).has("[variable]")) this.logic.updateVar(word, word + key, line, this.active.word);
    else line[this.active.word] += key;
    this.previousKeyLog = key;
  }
  onCtrlInput(word, line, key) {
    //console.log("____FUNC IN CTRL____");
    switch (key) {
      case this.keys.ctrl.gotoTop:
        this.previousKeyLog = "gotoTop: Ctrl + " + this.keys.ctrl.gotoTop;
        this.gotoLine(0);
        break;
      case this.keys.ctrl.gotoMiddle:
        this.previousKeyLog = "gotoMiddle: Ctrl + " + this.keys.ctrl.gotoMiddle;
        this.gotoLine(Math.floor(this.lines.length / 2));
        break;
      case this.keys.ctrl.gotoBottom:
        this.previousKeyLog = "gotoBottom: Ctrl + " + this.keys.ctrl.gotoBottom;
        this.gotoLine(this.lines.length - 1);
        break;
      case this.keys.ctrl.copyWord:
        this.previousKeyLog = "copyWord: Ctrl + " + this.keys.ctrl.copyWord;
        navigator.clipboard.writeText(word).then(() => {
          ////console.log("Navigator > Copied");
        });
        break;
      case this.keys.ctrl.cutWord:
        this.previousKeyLog = "cutWord: Ctrl + " + this.keys.ctrl.cutWord;
        navigator.clipboard.writeText(word).then(() => {
          ////console.log("Navigator > Cut");
          line[this.active.word] = "";
          this.render();
        });
        break;
      case this.keys.ctrl.pasteWord:
        this.previousKeyLog = "pasteWord: Ctrl + " + this.keys.ctrl.pasteWord;
        navigator.clipboard.readText().then((str) => {
          ////console.log("Navigator > Pasted");
          if (str.has("\n") || str.has(" ")) return;
          line[this.active.word] = str;

          this.render();
        });
        break;
      case this.keys.ctrl.zoomOut:
        this.previousKeyLog = "zoomOut: Ctrl + " + this.keys.ctrl.zoomOut;
        this.updateFont(-1);
        break;

      case this.keys.ctrl.zoomIn:
        this.previousKeyLog = "zoomIn: Ctrl + " + this.keys.ctrl.zoomIn;
        this.updateFont(1);
        break;
    }
  }

  newLine(arr, at = this.lines.length) {
    //console.log("____FUNC IN NEWLINE____");
    if (!Array.isArray(arr) || typeof arr[0] !== "string") throw new Error("Couldn't make new line, Ill-defined array was given." + arr);
    this.lines.splice(at, 0, arr);
  }
  onCommandUpdate(line, uline, lineIndex, ulineIndex) {
    //console.log("____FUNC IN ONCOMMANDUPDATE____");
    if (typeof line[1] !== "string" || lineIndex !== ulineIndex) return;
    if (line[0] === ".addlink" || uline[0] === ".addlink") {
      this.logic.buildings = null;
      this.logic.buildings = {};
      this.logic.linkedBuildings = null;
      this.logic.linkedBuildings = new Set();
      for (let i = 0; i < this.lines.length; i++) {
        let loopLine = this.lines[i];
        let loopFirstKeyword = loopLine[0];
        if (loopFirstKeyword !== ".addlink" || !suggestions.logicNames.has(loopLine[1])) continue;

        if (this.logic.buildings[loopLine[1]]) this.logic.buildings[loopLine[1]]++;
        else this.logic.buildings[loopLine[1]] = 1;
        this.logic.linkedBuildings.add(loopLine[1] + this.logic.buildings[loopLine[1]]);
      }
    } else if (line[0] === ".label" || uline[0] === ".label") {
      if (line[0] === ".label") this.updateLabel(uline[1], line[1], line, uline, lineIndex, ulineIndex);
      else if (this.logic.label[line[1]]) this.removeItemFrom(line[1], "label");
    } else throw new Error("line has to be command, instead recieved > " + line[0] + " Unchanged > " + uline[0]);
  }
  onCommand(line, lineIndex) {
    //console.log("____FUNC IN ONCOMMAND____");
    if (typeof line[1] !== "string" || line[1].trim() == "") return;
    switch (line[0]) {
      case ".addlink":
        if (parameters[1][".addlink"][0].has(line[1])) {
          if (this.logic.buildings[line[1]]) this.logic.buildings[line[1]]++;
          else this.logic.buildings[line[1]] = 1;
          this.logic.linkedBuildings.add(line[1] + this.logic.buildings[line[1]]);
        }

        break;
      case ".label":
        if (this.logic.isValidLabel(line, 1)) this.logic.addLabel(line[1]);
        break;

      default:
        throw new Error("The line has to be command. Wrong onCommand call.");
    }
  }
  onInput(e) {
    //console.log("____FUNC IN ONINPUT > " + e.key);
    e.preventDefault();
    let key = e.key;
    //console.log("KEY >" + key + "<");
  }
}
