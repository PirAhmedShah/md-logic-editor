import { parameters, logicGroups, emptySet, suggestions} from "../Objects/main.js";
import { isNumber, isComment, isAutoGenerated, isValidHex, isConstant } from "./utility.js";

let keywordMap;
export class SyntaxHighlighter {
  constructor(editor) {
    //console.log("____CON SYNTAX HIGHLIGHTER____");
    this.editor = editor;
    this.logic = editor.logic;
    this.renderer = editor.renderer;
    this.theme = this.renderer.theme;
    let conditions = {
      nums: (keyword) => (isNumber(keyword) ? this.theme.purple : this.logic.variable[keyword] ? this.theme.orange : this.theme.none),
      existingVars: (keyword) => (this.logic.variable[keyword] ? this.theme.orange : this.theme.none),
      color: (keyword) => (isValidHex(keyword) ? keyword.replace("%", "#") : this.theme.none),
      variable: (keyword) => (this.logic.variable[keyword] && !suggestions.readOnlyVarNames.has(keyword) ? this.theme.orange : this.theme.none),
      buildings: (keyword) => (this.logic.linkedBuildings.has(keyword) ? this.theme.blue : this.logic.variable[keyword] ? this.theme.orange : this.theme.none),
      state: (keyword) => (suggestions.stateValues.has(keyword) ? this.theme.purple : this.logic.variable[keyword] ? this.theme.orange : this.theme.none),
      radarTarget: (keyword) => (suggestions.radarTargetOptions.has(keyword) ? this.theme.green : this.theme.none),
      constant: (keyword) => (isConstant(keyword) ? this.theme.purple : this.logic.variable[keyword] ? this.theme.orange : this.theme.none),
      allVars: (keyword) => (isConstant(keyword) ? this.theme.purple : this.logic.variable[keyword] ? this.theme.orange : this.logic.linkedBuildings.has(keyword) ? this.theme.blue : 0),
      order: (keyword) => (suggestions.order.has(keyword) ? this.theme.purple : this.theme.none),
      itemNames: (keyword) => (suggestions.itemNames.has(keyword) ? this.theme.blue : this.theme.none),
    };
    conditions.opTwoVars = [conditions.variable, conditions.constant, conditions.constant];
    conditions.opOneVar = [conditions.variable, conditions.constant];
    keywordMap = {
      keywordWithOptions: {
        draw: [(keyword) => (parameters[1].draw[0].has(keyword) ? this.theme.green : this.theme.none)],
        op: [(keyword) => (parameters[1].op[0].has(keyword) ? this.theme.green : this.theme.none)],
        control: [(keyword) => (parameters[1].control[0].has(keyword) ? this.theme.green : this.theme.none)],
        ucontrol: [(keyword) => (parameters[1].ucontrol[0].has(keyword) ? this.theme.green : this.theme.none)],
        jump: [
          (keyword) => (this.logic.label[keyword] ? this.theme.green : isNumber(keyword) ? this.theme.purple : this.theme.none),
          (keyword) => (parameters[1].jump[1].has(keyword) ? this.theme.green : this.theme.none),
        ],
      },
      read: [conditions.variable, conditions.buildings, conditions.nums],
      write: [conditions.existingVars, conditions.buildings, conditions.nums],
      draw: {
        clear: [conditions.nums, conditions.nums, conditions.nums],
        //[R,G,B]
        color: [conditions.nums, conditions.nums, conditions.nums, conditions.nums],
        //[x y x2 y2]
        col: [conditions.color],
        line: [conditions.nums, conditions.nums, conditions.nums, conditions.nums],
        //[x y x2 y2]
        stroke: [conditions.nums],
        rect: [conditions.nums, conditions.nums, conditions.nums, conditions.nums],
        lineRect: [conditions.nums, conditions.nums, conditions.nums, conditions.nums],
        poly: [conditions.nums, conditions.nums, conditions.nums, conditions.nums, conditions.nums],
        linePoly: [conditions.nums, conditions.nums, conditions.nums, conditions.nums, conditions.nums],
        triangle: [conditions.nums, conditions.nums, conditions.nums, conditions.nums, conditions.nums, conditions.nums],
        image: [conditions.nums, conditions.nums, (keyword) => (parameters[1].draw[1].image[2].has(keyword) ? this.theme.blue : this.theme.none), conditions.nums, conditions.nums],
      },
      print: [conditions.existingVars],
      drawflush: [conditions.buildings],
      printflush: [conditions.buildings],
      getlink: [conditions.variable, conditions.nums],
      control: {
        enabled: [conditions.buildings, conditions.state],
        shoot: [conditions.buildings, conditions.nums, conditions.nums, conditions.state],
        shootp: [conditions.buildings, conditions.existingVars, conditions.state],
        config: [conditions.buildings, conditions.itemNames],
        color: [conditions.buildings, conditions.color],
      },
      radar: [
        conditions.radarTarget,
        conditions.radarTarget,
        conditions.radarTarget,
        (keyword) => (suggestions.radarSortOptions.has(keyword) ? this.theme.green : this.theme.none),
        conditions.buildings,
        conditions.order,
        conditions.variable,
      ],
      sensor: [conditions.variable, conditions.buildings, (keyword) => (parameters[1].sensor[2].has(keyword) ? this.theme.blue : this.theme.none)],
      set: conditions.opOneVar,
      op: {
        add: conditions.opTwoVars,
        sub: conditions.opTwoVars,
        mul: conditions.opTwoVars,
        div: conditions.opTwoVars,
        idiv: conditions.opTwoVars,
        mod: conditions.opTwoVars,
        pow: conditions.opTwoVars,
        equal: conditions.opTwoVars,
        notEqual: conditions.opTwoVars,
        land: conditions.opTwoVars,
        lessThan: conditions.opTwoVars,
        lessThanEq: conditions.opTwoVars,
        greaterThan: conditions.opTwoVars,
        greaterThanEq: conditions.opTwoVars,
        strictEqual: conditions.opTwoVars,
        shl: conditions.opTwoVars,
        shr: conditions.opTwoVars,
        or: conditions.opTwoVars,
        and: conditions.opTwoVars,
        xor: conditions.opTwoVars,
        not: conditions.opOneVar,
        max: conditions.opTwoVars,
        min: conditions.opTwoVars,
        angle: conditions.opTwoVars,
        angleDiff: conditions.opTwoVars,
        len: conditions.opTwoVars,
        noise: conditions.opTwoVars,
        abs: conditions.opOneVar,
        log: conditions.opOneVar,
        log10: conditions.opOneVar,
        floor: conditions.opOneVar,
        ceil: conditions.opOneVar,
        sqrt: conditions.opOneVar,
        rand: conditions.opOneVar,
        sin: conditions.opOneVar,
        cos: conditions.opOneVar,
        tan: conditions.opOneVar,
        asin: conditions.opOneVar,
        acos: conditions.opOneVar,
        atan: conditions.opOneVar,
      },

      lookup: [(keyword) => (parameters[1].lookup[0].has(keyword) ? this.theme.green : this.theme.none), conditions.variable, conditions.nums],
      packcolor: [conditions.variable, conditions.nums, conditions.nums, conditions.nums, conditions.nums],
      wait: [conditions.nums],
      stop: [emptySet],
      end: [emptySet],
      jump: {
        equal: [conditions.buildings, conditions.allVars],
        notEqual: [conditions.buildings, conditions.allVars],
        always: [],
        lessThan: [conditions.buildings, conditions.allVars],
        greaterThan: [conditions.buildings, conditions.allVars],
        lessThanEq: [conditions.buildings, conditions.allVars],
        greaterThanEq: [conditions.buildings, conditions.allVars],
      },

      ubind: [(keyword) => (this.logic.variable[keyword] ? this.theme.orange : suggestions.unitNames.has(keyword) ? this.theme.blue : this.theme.none)],
      ucontrol: {
        move: [conditions.nums, conditions.nums],
        idle: [],
        stop: [],
        mine: [conditions.nums, conditions.nums],
        unbind: [],
        approach: [conditions.nums, conditions.nums, conditions.nums],
        within: [conditions.variable, conditions.nums, conditions.nums, conditions.nums],
        flag: [conditions.nums],
        payEnter: [],
        payDrop: [],
        payTake: [conditions.state],
        itemTake: [conditions.buildings, conditions.itemNames, conditions.nums],
        itemDrop: [conditions.buildings, conditions.nums],
        boost: [conditions.state],
        target: [conditions.nums, conditions.nums, conditions.state],
        targetp: [conditions.existingVars, conditions.state],
        autoPathfind: [],
        pathfind: [conditions.nums, conditions.nums],
        getBlock: [conditions.nums, conditions.nums, conditions.variable, conditions.variable, conditions.variable],
      },
      uradar: [
        conditions.radarTarget,
        conditions.radarTarget,
        conditions.radarTarget,
        (keyword) => (suggestions.radarSortOptions.has(keyword) ? this.theme.green : this.theme.none),
        (keyword) => (keyword == "0" ? this.theme.purple : this.theme.none),
        conditions.order,
        conditions.variable,
      ],
      ulocate: [
        (keyword) => (suggestions.ulocateFindOptions.has(keyword) ? this.theme.green : this.theme.none),
        (keyword) => (suggestions.ulocateGroups.has(keyword) ? this.theme.green : this.theme.none),
        conditions.state,
        conditions.itemNames,
        conditions.variable,
        conditions.variable,
        conditions.variable,
        conditions.variable,
      ],
      ".addlink": [(keyword) => (parameters[1][".addlink"][0].has(keyword) ? this.theme.blue : this.theme.none)],
      //".func": [(keyword) =>this.theme.green, (keyword) =>this.theme.orange, (keyword) =>this.theme.orange],
      ".label": [(keyword) => (this.logic.label[keyword] ? this.theme.green : this.theme.none)],
    };
  }
  getTextColor(line, wordIndex, firstKeyword, keyword, withOptions, sI, secondKeyword) {
    //console.log("____FUNC SNX HG GET TEXT COLOR____");
    if (isComment(line) || isAutoGenerated(keyword)) return this.theme.comment;
    else if (wordIndex == 0) return this.theme[logicGroups.groupColors[logicGroups.keywordGroup[keyword]]] || this.theme.none;
    else {
      if (withOptions) {
        if (wordIndex <= 1 + sI) return keywordMap.keywordWithOptions[firstKeyword][wordIndex - 1](keyword, this);
        else return keywordMap[firstKeyword][secondKeyword][wordIndex - 2 - sI](keyword, this);
      } else return keywordMap[firstKeyword][wordIndex - 1](keyword, this);
    }
  }
}
