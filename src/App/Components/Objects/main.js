let database = {
  item: [
    "copper",
    "lead",
    "metaglass",
    "graphite",
    "sand",
    "coal",
    "titanium",
    "thorium",
    "scrap",
    "silicon",
    "plastanium",
    "phase-fabric",
    "surge-alloy",
    "spore-pod",
    "blast-compound",
    "pyratite",
    "beryllium",
    "fissile-matter",
    "dormant-cyst",
    "tungsten",
    "carbide",
    "oxide",
  ],
  unit: [
    "dagger",
    "mace",
    "fortress",
    "scepter",
    "reign",
    "nova",
    "pulsar",
    "quasar",
    "vela",
    "corvus",
    "crawler",
    "atrax",
    "spiroct",
    "arkyid",
    "toxopid",
    "flare",
    "horizon",
    "zenith",
    "antumbra",
    "eclipse",
    "mono",
    "poly",
    "mega",
    "quad",
    "oct",
    "risso",
    "minke",
    "bryde",
    "sei",
    "omura",
    "retusa",
    "oxynoe",
    "cyerce",
    "aegires",
    "navanax",
    "alpha",
    "beta",
    "gamma",
    "stell",
    "locus",
    "precept",
    "vanquish",
    "conquer",
    "merui",
    "cleroi",
    "anthicus",
    "tecta",
    "collaris",
    "elude",
    "avert",
    "obviate",
    "quell",
    "disrupt",
    "evoke",
    "incite",
    "emanate",
  ],
  liquid: ["water", "slag", "oil", "cryofluid", "neoplasm", "hydrogen", "ozone", "cyanogen", "gallium", "nitrogen", "arkycite"],
  block: [
    "graphite-press",
    "multi-press",
    "silicon-smelter",
    "silicon-crucible",
    "kiln",
    "plastanium-compressor",
    "phase-weaver",
    "cryofluid-mixer",
    "pyratite-mixer",
    "blast-mixer",
    "melter",
    "separator",
    "disassembler",
    "spore-press",
    "pulverizer",
    "coal-centrifuge",
    "incinerator",
    "copper-wall",
    "copper-wall-large",
    "titanium-wall",
    "titanium-wall-large",
    "plastanium-wall",
    "plastanium-wall-large",
    "thorium-wall",
    "thorium-wall-large",
    "phase-wall",
    "phase-wall-large",
    "surge-wall",
    "surge-wall-large",
    "door",
    "illuminator",
    "door-large",
    "scrap-wall",
    "scrap-wall-large",
    "scrap-wall-huge",
    "scrap-wall-gigantic",
    "mender",
    "mend-projector",
    "overdrive-projector",
    "overdrive-dome",
    "force-projector",
    "shock-mine",
    "conveyor",
    "titanium-conveyor",
    "plastanium-conveyor",
    "armored-conveyor",
    "junction",
    "bridge-conveyor",
    "phase-conveyor",
    "sorter",
    "inverted-sorter",
    "router",
    "distributor",
    "overflow-gate",
    "underflow-gate",
    "mass-driver",
    "duct",
    "duct-router",
    "duct-bridge",
    "mechanical-pump",
    "rotary-pump",
    "conduit",
    "pulse-conduit",
    "plated-conduit",
    "liquid-router",
    "liquid-tank",
    "liquid-junction",
    "bridge-conduit",
    "phase-conduit",
    "power-node",
    "power-node-large",
    "surge-tower",
    "diode",
    "battery",
    "battery-large",
    "combustion-generator",
    "thermal-generator",
    "steam-generator",
    "differential-generator",
    "rtg-generator",
    "solar-panel",
    "solar-panel-large",
    "thorium-reactor",
    "impact-reactor",
    "mechanical-drill",
    "pneumatic-drill",
    "laser-drill",
    "blast-drill",
    "water-extractor",
    "cultivator",
    "oil-extractor",
    "core-shard",
    "core-foundation",
    "core-nucleus",
    "vault",
    "container",
    "unloader",
    "duo",
    "scatter",
    "scorch",
    "hail",
    "wave",
    "lancer",
    "arc",
    "parallax",
    "swarmer",
    "salvo",
    "segment",
    "tsunami",
    "fuse",
    "ripple",
    "cyclone",
    "foreshadow",
    "spectre",
    "meltdown",
    "command-center",
    "ground-factory",
    "air-factory",
    "naval-factory",
    "additive-reconstructor",
    "multiplicative-reconstructor",
    "exponential-reconstructor",
    "logic-display",
    "large-logic-display",
    "switch",
    "message",
    "memory-cell",
    "memory-bank",
    "micro-processor",
    "logic-processor",
    "hyper-processor",
    "world-processor",
    "canvas",
  ],
};

const logicGroups = {
  groupColors: { IO: "lightOrange", BlockControl: "red", Operations: "purple", FlowControl: "blue", UnitControl: "yellow", Commands: "dullBlue" },
  keywordGroup: {
    read: "IO",
    write: "IO",
    print: "IO",
    draw: "IO",
    drawflush: "BlockControl",
    printflush: "BlockControl",
    control: "BlockControl",
    sensor: "BlockControl",
    radar: "BlockControl",
    getlink: "BlockControl",
    set: "Operations",
    op: "Operations",
    lookup: "Operations",
    packcolor: "Operations",
    jump: "FlowControl",
    wait: "FlowControl",
    stop: "FlowControl",
    end: "FlowControl",
    ubind: "UnitControl",
    ucontrol: "UnitControl",
    uradar: "UnitControl",
    ulocate: "UnitControl",
    ".label": "Commands",
    ".addlink": "Commands",
    //".func": "Commands",
  },
};
//variables existing_vars,
//existing_vars, existing_label, [string], [label], [variable], [number], [color], linked_buildings;

//existing_vars means existing variables that are not in readOnlyVarNames.
const suggestions = {
  buildings: ["linked_buildings", "existing_vars"],
  logicNames: new Set(database.block.map((str) => str.split("-").pop())),
  commands: new Set([".addlink", ".label"]),
  keywordWithOptions: new Set(["jump", "draw", "control", "op", "ucontrol"]),
  specialKeywords: new Set(["[number]", "[variable]", "[color]", "[label]"]),
  readOnlyVarNames: new Set([
    "@tick",
    "@time",
    "@ipt",
    "@link",
    "@mapw",
    "@maph",
    "@this",
    "@thisx",
    "@thisy",
    "@waveNumber",
    //ADD ALL BELOW TO DATABASE
    "@waveTime",
    "@second",
    "@minute",
  ]),
  keywordWithOptionsAutoFill: {
    jump: "[operator]",
    draw: "[type]",
    control: "[set]",
    op: "[operator]",
    ucontrol: "[action]",
  },
  state: ["true", "false", "1", "0", "existing_vars"],
  stateValues: new Set(["true", "false", "1", "0"]),
  numbers: ["[number]", "existing_vars"],
  constant: ["[number]", "existing_vars", "true", "false"],
  allVars: ["existing_vars", "linked_buildingss"],
  all: ["[number]", "existing_vars", "true", "false", "linked_buildingss"],
  variable: ["existing_vars", "[variable]"],

  lookupOptions: new Set(["item", "liquid", "block", "unit"]),
  radarTargetOptions: new Set(["any", "enemy", "player", "ally", "ground", "flying", "attacker", "boss"]),
  radarSortOptions: new Set(["distance", "health", "shield", "armor", "maxHealth"]),
  drawOptions: new Set(["clear", "color", "col", "line", "stroke", "rect", "lineRect", "poly", "linePoly", "triangle", "image"]),
  controlOptions: new Set(["enabled", "shoot", "shootp", "config", "color"]),
  ulocateFindOptions: new Set(["ore", "building", "spawn", "damaged"]),
  ulocateGroups: new Set(["core", "storage", "generator", "turret", "factory", "repair", "battery", "reactor"]),
  uControlOptions: new Set([
    "move",
    "idle",
    "stop",
    "mine",
    "unbind",
    "approach",
    "within",
    "flag",
    "payEnter",
    "payDrop",
    "payTake",
    "itemTake",
    "itemDrop",
    "boost",
    "target",
    "targetp",
    "autoPathfind",
    "pathfind",
    "getBlock",
  ]),
  jumpOperators: new Set(["equal", "notEqual", "always", "lessThan", "greaterThan", "lessThanEq", "greaterThanEq"]),
  operators: new Set([
    "add",
    "sub",
    "mul",
    "div",
    "idiv",
    "mod",
    "pow",
    "equal",
    "notEqual",
    "land",
    "lessThan",
    "lessThanEq",
    "greaterThan",
    "greaterThanEq",
    "strictEqual",
    "shl",
    "shr",
    "or",
    "and",
    "xor",
    "not",
    "max",
    "min",
    "angle",
    "angleDiff",
    "len",
    "noise",
    "abs",
    "log",
    "log10",
    "floor",
    "ceil",
    "sqrt",
    "rand",
    "sin",
    "cos",
    "tan",
    "asin",
    "atan",
    "acos",
  ]),
  otherSensableProperties: new Set([
    "@totalItems",
    "@firstItem",
    "@totalLiquids",
    "@totalPower",
    "@itemCapacity",
    "@liquidCapacity",
    "@powerCapacity",
    "@powerNetStored",
    "@powerNetCapacity",
    "@powerNetIn",
    "@powerNetOut",
    "@ammo",
    "@ammoCapacity",
    "@health",
    "@maxHealth",
    "@heat",
    "@shield",
    "@armor",
    "@efficiency",
    "@progress",
    "@timescale",
    "@rotation",
    "@x",
    "@y",
    "@shootX",
    "@shootY",
    "@cameraX",
    "@cameraY",
    "@cameraWidth",
    "@cameraHeight",
    "@size",
    "@dead",
    "@range",
    "@shooting",
    "@boosting",
    "@mineX",
    "@mineY",
    "@mining",
    "@speed",
    "@team",
    "@type",
    "@flag",
    "@controlled",
    "@controller",
    "@name",
    "@payloadCount",
    "@payloadType",
    "@id",
  ]),
  unitNames: new Set([...database.unit].map((str) => "@" + str)),
  itemNames: new Set([...database.item].map((str) => "@" + str)),
  blockNames: new Set([...database.block].map((str) => "@" + str)),
  liquidNames: new Set([...database.liquid].map((str) => "@" + str)),
};
suggestions.allNames = new Set([...suggestions.unitNames, ...suggestions.itemNames, ...suggestions.blockNames, ...suggestions.liquidNames]);
suggestions.allSensables = new Set([...suggestions.itemNames, ...suggestions.liquidNames, ...suggestions.otherSensableProperties]);
const autoSuggest = {
  read: ["[result]", "[from]", "[at]"],
  write: ["[value]", "[to]", "[at]"],
  ".addlink": ["[building]"],
  //".func": ["[function name]", "[parameter1]", "[parameter2]"],
  "#": ["[comment]"],
  ".label": ["[name]"],
  draw: {
    clear: ["[red]", "[green]", "[blue]"],
    //[R,G,B]
    color: ["[red]", "[green]", "[blue]", "[alpha]"],
    //[R,G,B]

    col: ["[hex color]"],

    line: ["[x1]", "[y1]", "[x2]", "[y2]"],
    //[x y x2 y2]
    stroke: ["[width]"],
    rect: ["[x1]", "[y1]", "[width]", "[height]"],
    lineRect: ["[x1]", "[y1]", "[width]", "[height]"],
    //[x y x2 y2]
    poly: ["[x]", "[y]", "[sides]", "[radius]", "[rotation]"],
    linePoly: ["[x]", "[y]", "[sides]", "[radius]", "[rotation]"],
    triangle: ["[x1]", "[y1]", "[x2]", "[y2]", "[x3]", "[y3]"],
    image: ["[x]", "[y]", "[size]", "[image]", "[rotation]"],
  },
  print: ["[string or var]"],
  drawflush: ["[to]"],
  printflush: ["[to]"],
  getlink: ["[result]", "[id]"],
  control: {
    enabled: ["[building]", "[enabled]"],
    shoot: ["[turret]", "[x]", "[y]", "[shoot]"],
    shootp: ["[turret]", "[unit]", "[shoot]"],
    config: ["[building]", "[to]"],
    color: ["[illuminator]", "[color]"],
  },
  radar: ["[target]", "[and]", "[and]", "[sort]", "[building]", "[order]", "[result]"],
  sensor: ["[result]", "[building]", "[@property]"],
  set: ["[result]", "[value]"],
  op: {
    add: ["[result]", "[operand]", "[operand]"],
    sub: ["[result]", "[operand]", "[operand]"],
    mul: ["[result]", "[operand]", "[operand]"],
    div: ["[result]", "[operand]", "[operand]"],
    idiv: ["[result]", "[operand]", "[operand]"],
    mod: ["[result]", "[operand]", "[operand]"],
    pow: ["[result]", "[operand]", "[operand]"],
    equal: ["[result]", "[operand]", "[operand]"],
    notEqual: ["[result]", "[operand]", "[operand]"],
    land: ["[result]", "[operand]", "[operand]"],
    lessThan: ["[result]", "[operand]", "[operand]"],
    lessThanEq: ["[result]", "[operand]", "[operand]"],
    greaterThan: ["[result]", "[operand]", "[operand]"],
    greaterThanEq: ["[result]", "[operand]", "[operand]"],
    strictEqual: ["[result]", "[operand]", "[operand]"],
    shl: ["[result]", "[operand]", "[operand]"],
    shr: ["[result]", "[operand]", "[operand]"],
    or: ["[result]", "[operand]", "[operand]"],
    and: ["[result]", "[operand]", "[operand]"],
    xor: ["[result]", "[operand]", "[operand]"],
    not: ["[result]", "[operand]"],
    max: ["[result]", "[operand]", "[operand]"],
    min: ["[result]", "[operand]", "[operand]"],
    angle: ["[result]", "[operand]", "[operand]"],
    angleDiff: ["[result]", "[operand]", "[operand]"],
    len: ["[result]", "[operand]", "[operand]"],
    noise: ["[result]", "[operand]", "[operand]"],
    abs: ["[result]", "[operand]"],
    log: ["[result]", "[operand]"],
    log10: ["[result]", "[operand]"],
    floor: ["[result]", "[operand]"],
    ceil: ["[result]", "[operand]"],
    sqrt: ["[result]", "[operand]"],
    rand: ["[result]", "[operand]"],
    sin: ["[result]", "[operand]"],
    cos: ["[result]", "[operand]"],
    tan: ["[result]", "[operand]"],
    asin: ["[result]", "[operand]"],
    acos: ["[result]", "[operand]"],
    atan: ["[result]", "[operand]"],
  },
  lookup: ["[type]", "[result]", "[id]"],
  packcolor: ["[result]", "[redPercent]", "[greenPercent]", "[bluePercent]", "[alphaPercent]"],
  wait: ["[seconds]"],
  stop: [],
  end: [],
  jump: {
    equal: ["[operand]", "[operand]"],
    notEqual: ["[operand]", "[operand]"],
    always: [],
    lessThan: ["[operand]", "[operand]"],
    greaterThan: ["[operand]", "[operand]"],
    lessThanEq: ["[operand]", "[operand]"],
    greaterThanEq: ["[operand]", "[operand]"],
  },
  ubind: ["[@unit]"],
  ucontrol: {
    move: ["[x]", "[y]"],
    idle: [],
    stop: [],
    mine: ["[x]", "[y]"],
    unbind: [],
    approach: ["[x]", "[y]", "[radius]"],
    within: ["[x]", "[y]", "[radius]", "[result]"],
    flag: [],
    payEnter: [],
    payDrop: [],
    payTake: ["[take units]"],
    itemTake: ["[from]", "[@item]", "[amount]"],
    itemDrop: ["[to]", "[amount]"],
    boost: ["[enable]"],
    target: ["[x]", "[y]", "[shoot]"],
    targetp: ["[unit]", "[shoot]"],
    autoPathfind: [],
    pathfind: ["[x]", "[y]"],
    getBlock: ["[x]", "[y]", "[type]", "[building]", "[floor]"],
  },
  uradar: ["[target]", "[and]", "[and]", "[sort]", "[0]", "[order]", "[result]"],
  ulocate: ["[find]", "[group]", "[enemy]", "[@ore]", "[x]", "[y]", "[found]", "[building]"],
};
let emptySet = new Set();
let parms = {
  varOnly: new Set(["[variable]"]),
  buildingsOnly: new Set(suggestions.buildings),
  numbersOnly: new Set(suggestions.numbers),
  existingVarsOnly: new Set(["existing_vars"]),
  colorOnly: new Set(["[color]"]),
  radarTargetOptionsOnly: new Set(suggestions.radarTargetOptions),

  stateOnly: new Set(suggestions.state),
  radarSortOptionsOnly: new Set(suggestions.radarSortOptions),
  variable: new Set(suggestions.variable),
  constant: new Set(suggestions.constant),
  allVars: new Set(suggestions.allVars),
  all: new Set(suggestions.all),
  orderOnly: new Set(["0", "1"]),
};
const parameters = {
  0: new Set([
    "read",
    "write",
    "draw",
    "print",
    "printflush",
    "drawflush",
    "getlink",
    "control",
    "radar",
    "sensor",
    "op",
    "set",
    "lookup",
    "packcolor",
    "wait",
    "stop",
    "end",
    "jump",
    "ubind",
    "ucontrol",
    "ulocate",
    "uradar",
    ".addlink",
   // ".func",
    ".label",
    "#",
  ]),
  1: {
    ".addlink": [new Set(suggestions.logicNames)],
   // ".func": [emptySet, parms.varOnly,parms.varOnly],
    ".label": [new Set(["[label]"])],
    "#": [emptySet],
    read: [parms.varOnly, parms.buildingsOnly, parms.numbersOnly],
    write: [parms.existingVarsOnly, parms.buildingsOnly, parms.numbersOnly],
    draw: [
      new Set(suggestions.drawOptions),
      {
        clear: [parms.numbersOnly, parms.numbersOnly, parms.numbersOnly],
        //[R,G,B]
        color: [parms.numbersOnly, parms.numbersOnly, parms.numbersOnly, parms.numbersOnly],
        //[x y x2 y2]
        col: [parms.colorOnly],
        line: [parms.numbersOnly, parms.numbersOnly, parms.numbersOnly, parms.numbersOnly],
        //[x y x2 y2]
        stroke: [parms.numbersOnly],
        rect: [parms.numbersOnly, parms.numbersOnly, parms.numbersOnly, parms.numbersOnly],
        lineRect: [parms.numbersOnly, parms.numbersOnly, parms.numbersOnly, parms.numbersOnly],
        poly: [parms.numbersOnly, parms.numbersOnly, parms.numbersOnly, parms.numbersOnly, parms.numbersOnly],
        linePoly: [parms.numbersOnly, parms.numbersOnly, parms.numbersOnly, parms.numbersOnly, parms.numbersOnly],
        triangle: [parms.numbersOnly, parms.numbersOnly, parms.numbersOnly, parms.numbersOnly, parms.numbersOnly, parms.numbersOnly],
        image: [parms.numbersOnly, parms.numbersOnly, suggestions.allNames, parms.numbersOnly, parms.numbersOnly],
      },
    ],
    print: [parms.existingVarsOnly],
    drawflush: [parms.buildingsOnly],
    printflush: [parms.buildingsOnly],
    getlink: [parms.varOnly, parms.numbersOnly],
    control: [
      suggestions.controlOptions,
      {
        enabled: [parms.buildingsOnly, parms.stateOnly],
        shoot: [parms.buildingsOnly, parms.numbersOnly, parms.numbersOnly, parms.stateOnly],
        shootp: [parms.buildingsOnly, parms.existingVarsOnly, parms.stateOnly],
        config: [parms.buildingsOnly, suggestions.itemNames],
        color: [parms.buildingsOnly, parms.colorOnly],
      },
    ],
    radar: [parms.radarTargetOptionsOnly, parms.radarTargetOptionsOnly, parms.radarTargetOptionsOnly, parms.radarSortOptionsOnly, parms.buildingsOnly, parms.orderOnly, parms.varOnly],
    sensor: [parms.varOnly, parms.buildingsOnly, suggestions.allSensables],
    set: [parms.variable, parms.constant],
    op: [
      suggestions.operators,
      {
        add: [parms.variable, parms.constant, parms.constant],
        sub: [parms.variable, parms.constant, parms.constant],
        mul: [parms.variable, parms.constant, parms.constant],
        div: [parms.variable, parms.constant, parms.constant],
        idiv: [parms.variable, parms.constant, parms.constant],
        mod: [parms.variable, parms.constant, parms.constant],
        pow: [parms.variable, parms.constant, parms.constant],
        equal: [parms.variable, parms.constant, parms.constant],
        notEqual: [parms.variable, parms.constant, parms.constant],
        land: [parms.variable, parms.constant, parms.constant],
        lessThan: [parms.variable, parms.constant, parms.constant],
        lessThanEq: [parms.variable, parms.constant, parms.constant],
        greaterThan: [parms.variable, parms.constant, parms.constant],
        greaterThanEq: [parms.variable, parms.constant, parms.constant],
        strictEqual: [parms.variable, parms.constant, parms.constant],
        shl: [parms.variable, parms.constant, parms.constant],
        shr: [parms.variable, parms.constant, parms.constant],
        or: [parms.variable, parms.constant, parms.constant],
        and: [parms.variable, parms.constant, parms.constant],
        xor: [parms.variable, parms.constant, parms.constant],
        not: [parms.variable, parms.constant],
        max: [parms.variable, parms.constant, parms.constant],
        min: [parms.variable, parms.constant, parms.constant],
        angle: [parms.variable, parms.constant, parms.constant],
        angleDiff: [parms.variable, parms.constant, parms.constant],
        len: [parms.variable, parms.constant, parms.constant],
        noise: [parms.variable, parms.constant, parms.constant],
        abs: [parms.variable, parms.constant],
        log: [parms.variable, parms.constant],
        log10: [parms.variable, parms.constant],
        floor: [parms.variable, parms.constant],
        ceil: [parms.variable, parms.constant],
        sqrt: [parms.variable, parms.constant],
        rand: [parms.variable, parms.constant],
        sin: [parms.variable, parms.constant],
        cos: [parms.variable, parms.constant],
        tan: [parms.variable, parms.constant],
        asin: [parms.variable, parms.constant],
        acos: [parms.variable, parms.constant],
        atan: [parms.variable, parms.constant],
      },
    ],

    lookup: [suggestions.lookupOptions, parms.varOnly, parms.numbersOnly],
    packcolor: [parms.varOnly, parms.numbersOnly, parms.numbersOnly, parms.numbersOnly, parms.numbersOnly],
    wait: [parms.numbersOnly],
    stop: [emptySet],
    end: [emptySet],
    jump: [
      new Set(["existing_label", "[number]"]),
      suggestions.jumpOperators,
      {
        equal: [parms.allVars, parms.all],
        notEqual: [parms.allVars, parms.all],
        always: [],
        lessThan: [parms.allVars, parms.all],
        greaterThan: [parms.allVars, parms.all],
        lessThanEq: [parms.allVars, parms.all],
        greaterThanEq: [parms.allVars, parms.all],
      },
    ],

    ubind: [new Set([...suggestions.unitNames, "existing_vars"])],
    ucontrol: [
      suggestions.uControlOptions,
      {
        move: [parms.numbersOnly, parms.numbersOnly],
        idle: [],
        stop: [],
        mine: [parms.numbersOnly, parms.numbersOnly],
        unbind: [],
        approach: [parms.numbersOnly, parms.numbersOnly, parms.numbersOnly],
        within: [parms.varOnly, parms.numbersOnly, parms.numbersOnly, parms.numbersOnly],
        flag: [parms.numbersOnly],
        payEnter: [],
        payDrop: [],
        payTake: [parms.stateOnly],
        itemTake: [parms.buildingsOnly, suggestions.itemNames, parms.numbersOnly],
        itemDrop: [parms.buildingsOnly, parms.numbersOnly],
        boost: [parms.stateOnly],
        target: [parms.numbersOnly, parms.numbersOnly, parms.stateOnly],
        targetp: [parms.existingVarsOnly, parms.stateOnly],
        autoPathfind: [],
        pathfind: [parms.numbersOnly, parms.numbersOnly],
        getBlock: [parms.numbersOnly, parms.numbersOnly, parms.varOnly, parms.varOnly, parms.varOnly],
      },
    ],
    uradar: [parms.radarTargetOptionsOnly, parms.radarTargetOptionsOnly, parms.radarTargetOptionsOnly, parms.radarSortOptionsOnly, parms.buildingsOnly, parms.orderOnly, parms.varOnly],
    ulocate: [suggestions.ulocateFindOptions, suggestions.ulocateGroups, parms.stateOnly, suggestions.itemNames, parms.varOnly, parms.varOnly, parms.varOnly, parms.varOnly],
  },
};
let repeated = {
  nums: (keyword, editor) => (editor.isNumber(keyword) ? editor.theme.purple : editor.isExisting(keyword, "variable") ? editor.theme.orange : "#ffffff"),
  existingVars: (keyword, editor) => (editor.isExisting(keyword, "variable") ? editor.theme.orange : "#ffffff"),
  color: (keyword, editor) => (editor.isValidHex(keyword) ? keyword.replace("%", "#") : "#ffffff"),
  variable: (keyword, editor) => (editor.isExisting(keyword, "variable") && !suggestions.readOnlyVarNames.has(keyword) ? editor.theme.orange : "#ffffff"),
  buildings: (keyword, editor) => (editor.linkedBuildings.has(keyword) ? editor.theme.blue : editor.isExisting(keyword, "variable") ? editor.theme.orange : "#ffffff"),
  state: (keyword, editor) => (suggestions.stateValues.has(keyword) ? editor.theme.purple : editor.isExisting(keyword, "variable") ? editor.theme.orange : "#ffffff"),
  radarTarget: (keyword, editor) => (parms.radarTargetOptionsOnly.has(keyword) ? editor.theme.green : "#ffffff"),
  constant: (keyword, editor) => (editor.isConstant(keyword) ? editor.theme.purple : editor.isExisting(keyword, "variable") ? editor.theme.orange : "#ffffff"),
  allVars: (keyword, editor) =>
    editor.isConstant(keyword) ? editor.theme.purple : editor.isExisting(keyword, "variable") ? editor.theme.orange : editor.linkedBuildings.has(keyword) ? editor.theme.blue : 0,
  order: (keyword, editor) => (parms.orderOnly.has(keyword) ? editor.theme.purple : "#ffffff"),
  itemNames: (keyword, editor) => (suggestions.itemNames.has(keyword) ? editor.theme.blue : "#ffffff"),
};
repeated.opTwoVars = [repeated.variable, repeated.constant, repeated.constant];
repeated.opOneVar = [repeated.variable, repeated.constant];
const syntaxHighlighter = {
  keywordWithOptions: {
    draw: [(keyword, editor) => (parameters[1].draw[0].has(keyword) ? editor.theme.green : "#ffffff")],
    op: [(keyword, editor) => (parameters[1].op[0].has(keyword) ? editor.theme.green : "#ffffff")],
    control: [(keyword, editor) => (parameters[1].control[0].has(keyword) ? editor.theme.green : "#ffffff")],
    ucontrol: [(keyword, editor) => (parameters[1].ucontrol[0].has(keyword) ? editor.theme.green : "#ffffff")],
    jump: [
      (keyword, editor) => (editor.isExisting(keyword, "label") ? editor.theme.green : editor.isNumber(keyword) ? editor.theme.purple : "#ffffff"),
      (keyword, editor) => (parameters[1].jump[1].has(keyword) ? editor.theme.green : "#ffffff"),
    ],
  },
  read: [repeated.variable, repeated.buildings, repeated.nums],
  write: [repeated.existingVars, repeated.buildings, repeated.nums],
  draw: {
    clear: [repeated.nums, repeated.nums, repeated.nums],
    //[R,G,B]
    color: [repeated.nums, repeated.nums, repeated.nums, repeated.nums],
    //[x y x2 y2]
    col: [repeated.color],
    line: [repeated.nums, repeated.nums, repeated.nums, repeated.nums],
    //[x y x2 y2]
    stroke: [repeated.nums],
    rect: [repeated.nums, repeated.nums, repeated.nums, repeated.nums],
    lineRect: [repeated.nums, repeated.nums, repeated.nums, repeated.nums],
    poly: [repeated.nums, repeated.nums, repeated.nums, repeated.nums, repeated.nums],
    linePoly: [repeated.nums, repeated.nums, repeated.nums, repeated.nums, repeated.nums],
    triangle: [repeated.nums, repeated.nums, repeated.nums, repeated.nums, repeated.nums, repeated.nums],
    image: [repeated.nums, repeated.nums, (keyword) => (parameters[1].draw[1].image[2].has(keyword) ? editor.theme.blue : "#ffffff"), repeated.nums, repeated.nums],
  },
  print: [repeated.existingVars],
  drawflush: [repeated.buildings],
  printflush: [repeated.buildings],
  getlink: [repeated.variable, repeated.nums],
  control: {
    enabled: [repeated.buildings, repeated.state],
    shoot: [repeated.buildings, repeated.nums, repeated.nums, repeated.state],
    shootp: [repeated.buildings, repeated.existingVars, repeated.state],
    config: [repeated.buildings, repeated.itemNames],
    color: [repeated.buildings, repeated.color],
  },
  radar: [
    repeated.radarTarget,
    repeated.radarTarget,
    repeated.radarTarget,
    (keyword, editor) => (parms.radarSortOptionsOnly.has(keyword) ? editor.theme.green : "#ffffff"),
    repeated.buildings,
    repeated.order,
    repeated.variable,
  ],
  sensor: [repeated.variable, repeated.buildings, (keyword, editor) => (parameters[1].sensor[2].has(keyword) ? editor.theme.blue : "#ffffff")],
  set: repeated.opOneVar,
  op: {
    add: repeated.opTwoVars,
    sub: repeated.opTwoVars,
    mul: repeated.opTwoVars,
    div: repeated.opTwoVars,
    idiv: repeated.opTwoVars,
    mod: repeated.opTwoVars,
    pow: repeated.opTwoVars,
    equal: repeated.opTwoVars,
    notEqual: repeated.opTwoVars,
    land: repeated.opTwoVars,
    lessThan: repeated.opTwoVars,
    lessThanEq: repeated.opTwoVars,
    greaterThan: repeated.opTwoVars,
    greaterThanEq: repeated.opTwoVars,
    strictEqual: repeated.opTwoVars,
    shl: repeated.opTwoVars,
    shr: repeated.opTwoVars,
    or: repeated.opTwoVars,
    and: repeated.opTwoVars,
    xor: repeated.opTwoVars,
    not: repeated.opOneVar,
    max: repeated.opTwoVars,
    min: repeated.opTwoVars,
    angle: repeated.opTwoVars,
    angleDiff: repeated.opTwoVars,
    len: repeated.opTwoVars,
    noise: repeated.opTwoVars,
    abs: repeated.opOneVar,
    log: repeated.opOneVar,
    log10: repeated.opOneVar,
    floor: repeated.opOneVar,
    ceil: repeated.opOneVar,
    sqrt: repeated.opOneVar,
    rand: repeated.opOneVar,
    sin: repeated.opOneVar,
    cos: repeated.opOneVar,
    tan: repeated.opOneVar,
    asin: repeated.opOneVar,
    acos: repeated.opOneVar,
    atan: repeated.opOneVar,
  },

  lookup: [(keyword, editor) => (parameters[1].lookup[0].has(keyword) ? editor.theme.green : "#ffffff"), repeated.variable, repeated.nums],
  packcolor: [repeated.variable, repeated.nums, repeated.nums, repeated.nums, repeated.nums],
  wait: [repeated.nums],
  stop: [emptySet],
  end: [emptySet],
  jump: {
    equal: [repeated.buildings, repeated.allVars],
    notEqual: [repeated.buildings, repeated.allVars],
    always: [],
    lessThan: [repeated.buildings, repeated.allVars],
    greaterThan: [repeated.buildings, repeated.allVars],
    lessThanEq: [repeated.buildings, repeated.allVars],
    greaterThanEq: [repeated.buildings, repeated.allVars],
  },

  ubind: [(keyword, editor) => (editor.isExisting(keyword, "variable") ? editor.theme.orange : suggestions.unitNames.has(keyword) ? editor.theme.blue : "#ffffff")],
  ucontrol: {
    move: [repeated.nums, repeated.nums],
    idle: [],
    stop: [],
    mine: [repeated.nums, repeated.nums],
    unbind: [],
    approach: [repeated.nums, repeated.nums, repeated.nums],
    within: [repeated.variable, repeated.nums, repeated.nums, repeated.nums],
    flag: [repeated.nums],
    payEnter: [],
    payDrop: [],
    payTake: [repeated.state],
    itemTake: [repeated.buildings, repeated.itemNames, repeated.nums],
    itemDrop: [repeated.buildings, repeated.nums],
    boost: [repeated.state],
    target: [repeated.nums, repeated.nums, repeated.state],
    targetp: [repeated.existingVars, repeated.state],
    autoPathfind: [],
    pathfind: [repeated.nums, repeated.nums],
    getBlock: [repeated.nums, repeated.nums, repeated.variable, repeated.variable, repeated.variable],
  },
  uradar: [
    repeated.radarTarget,
    repeated.radarTarget,
    repeated.radarTarget,
    (keyword, editor) => (parms.radarSortOptionsOnly.has(keyword) ? editor.theme.green : "#ffffff"),
    (keyword, editor) => (keyword == "0" ? editor.theme.purple : "#ffffff"),
    repeated.order,
    repeated.variable,
  ],
  ulocate: [
    (keyword, editor) => (suggestions.ulocateFindOptions.has(keyword) ? editor.theme.green : "#ffffff"),
    (keyword, editor) => (suggestions.ulocateGroups.has(keyword) ? editor.theme.green : "#ffffff"),
    repeated.state,
    repeated.itemNames,
    repeated.variable,
    repeated.variable,
    repeated.variable,
    repeated.variable,
  ],
  ".addlink": [(keyword, editor) => (parameters[1][".addlink"][0].has(keyword) ? editor.theme.blue : "#ffffff")],
  //".func": [(keyword, editor) => editor.theme.green, (keyword, editor) => editor.theme.orange, (keyword, editor) => editor.theme.orange],
  ".label": [(keyword, editor) => (editor.isExisting(keyword, "label") ? editor.theme.green : "#ffffff")],
};
const forbiddenVarName = new Set([
  ...parameters[0],
  ...suggestions.allNames,
  ...suggestions.otherSensableProperties,
  ...suggestions.operators,
  ...suggestions.uControlOptions,
  ...suggestions.controlOptions,
  ...suggestions.ulocateGroups,
  ...suggestions.ulocateFindOptions,
  ...suggestions.drawOptions,
  ...suggestions.lookupOptions,
  ...suggestions.radarSortOptions,
  ...suggestions.radarTargetOptions,
  ...suggestions.radarTargetOptions,
  ...suggestions.readOnlyVarNames,
  "always",
]);
export { database, logicGroups, suggestions, autoSuggest, forbiddenVarName, parameters, syntaxHighlighter, emptySet };
